#!/usr/bin/env bash
# shellcheck disable=SC2155,SC2181

IMAGE_TAG='ghcr.io/tashigg/tashi-depin-worker:0'

TROUBLESHOOT_LINK='https://docs.tashi.network/nodes/node-installation/important-notes#troubleshooting'
MANUAL_UPDATE_LINK='https://docs.tashi.network/nodes/node-installation/important-notes#manual-update'

DOCKER_ROOTLESS_LINK='https://docs.docker.com/engine/install/linux-postinstall/'
PODMAN_ROOTLESS_LINK='https://github.com/containers/podman/blob/main/docs/tutorials/rootless_tutorial.md'

RUST_LOG='info,tashi_depin_worker=debug,tashi_depin_common=debug'

AGENT_PORT=39065

# Color codes
GREEN="\e[32m"
RED="\e[31m"
YELLOW="\e[33m"
BLUE="\e[34m"
CYAN="\e[36m"
RESET="\e[0m"
CHECKMARK="${GREEN}âœ“${RESET}"
CROSSMARK="${RED}âœ—${RESET}"
WARNING="${YELLOW}âš ${RESET}"
INFO="${BLUE}â„¹${RESET}"

STYLE_BOLD=$(tput bold)
STYLE_NORMAL=$(tput sgr0)

WARNINGS=0
ERRORS=0

# å¼€å‘è€…æ¨¡å¼å¼€å…³ï¼ˆé»˜è®¤å…³é—­ï¼‰
DEV_MODE=false

# è§£æå‘½ä»¤è¡Œå‚æ•°
while [[ $# -gt 0 ]]; do
    case $1 in
        --dev-mode|--skip-device-check)
            DEV_MODE=true
            echo -e "${YELLOW}âš ï¸ å¼€å‘è€…æ¨¡å¼ï¼šè·³è¿‡è®¾å¤‡æ£€æŸ¥${RESET}"
            shift
            ;;
        --help)
            echo "ä½¿ç”¨æ–¹æ³•: ./install.sh [é€‰é¡¹]"
            echo "é€‰é¡¹:"
            echo "  --dev-mode    å¼€å‘è€…æ¨¡å¼ï¼ˆè·³è¿‡è®¾å¤‡æ£€æŸ¥ï¼‰"
            echo "  --help        æ˜¾ç¤ºæ­¤å¸®åŠ©ä¿¡æ¯"
            exit 0
            ;;
        *)
            shift
            ;;
    esac
done

# Logging function
log() {
    local message="${2:-$(cat)}"
    if [[ "${LOG_EXPANDED:-0}" -ne 0 ]]; then
        local level="$1"
        local timestamp=$(date +"%Y-%m-%d %H:%M:%S")
        printf "[%s] [%s] %b\n" "${timestamp}" "${level}" "${message}" 1>&2
    else
        printf "%b\n" "$message"
    fi
}

make_bold() {
    local s="${1:-$(cat)}"
    printf "%s%s%s" "$STYLE_BOLD" "${s}" "$STYLE_NORMAL"
}

horizontal_line() {
    WIDTH=${COLUMNS:-$(tput cols)}
    FILL_CHAR='-'
    printf '\n%*s\n\n' "$WIDTH" '' | tr ' ' "$FILL_CHAR"
}

# Detect OS safely
detect_os() {
    OS=$(
        source /etc/os-release >/dev/null 2>&1
        echo "${ID:-unknown}"
    )
    if [[ "$OS" == "unknown" && "$(uname -s)" == "Darwin" ]]; then
        OS="macos"
    fi
}

suggest_install() {
    local package=$1
    case "$OS" in
        debian | ubuntu) echo "    sudo apt update && sudo apt install -y $package" ;;
        fedora) echo "    sudo dnf install -y $package" ;;
        arch) echo "    sudo pacman -S --noconfirm $package" ;;
        opensuse) echo "    sudo zypper install -y $package" ;;
        macos) echo "    brew install $package" ;;
        *) echo "    Please install '$package' manually for your OS." ;;
    esac
}

NPROC_CMD=$(command -v nproc || echo "")
GREP_CMD=$(command -v grep || echo "")
DF_CMD=$(command -v df || echo "")

check_command() {
    command -v "$1" >/dev/null 2>&1
}

check_platform() {
    PLATFORM_ARG=''
    local arch=$(uname -m)

    if [[ "$arch" == "amd64" || "$arch" == "x86_64" ]]; then
        log "INFO" "Platform Check: ${CHECKMARK} supported platform $arch"
    elif [[ "$OS" == "macos" && "$arch" == arm64 ]]; then
        PLATFORM_ARG='--platform linux/amd64'
        log "WARNING" "Platform Check: ${WARNING} unsupported platform $arch"
        log "INFO" <<-EOF
            MacOS Apple Silicon is not currently supported, but the worker can still run through the Rosetta compatibility layer.
            Performance and earnings will be less than a native node.
            You may be prompted to install Rosetta when the worker node starts.
        EOF
        ((WARNINGS++))
    else
        log "ERROR" "Platform Check: ${CROSSMARK} unsupported platform $arch"
        log "INFO" "Join the Tashi Discord to request support for your system."
        ((ERRORS++))
        return
    fi
}

check_cpu() {
    case "$OS" in
        "macos")
            threads=$(sysctl -n hw.ncpu)
            ;;
        *)
            if [[ -z "$NPROC_CMD" ]]; then
                log "WARNING" "'nproc' not found. Install coreutils:"
                suggest_install "coreutils"
                ((ERRORS++))
                return
            fi
            threads=$("$NPROC_CMD")
            ;;
    esac

    if [[ "$threads" -ge 4 ]]; then
        log "INFO" "CPU Check: ${CHECKMARK} Found $threads threads (>= 4 recommended)"
    elif [[ "$threads" -ge 2 ]]; then
        log "WARNING" "CPU Check: ${WARNING} Found $threads threads (>= 2 required, 4 recommended)"
        ((WARNINGS++))
    else
        log "ERROR" "CPU Check: ${CROSSMARK} Only $threads threads found (Minimum: 2 required)"
        ((ERRORS++))
    fi
}

check_memory() {
    if [[ -z "$GREP_CMD" ]]; then
        log "ERROR" "Memory Check: ${WARNING} 'grep' not found. Install grep:"
        suggest_install "grep"
        ((ERRORS++))
        return
    fi

    case "$OS" in
        "macos")
            total_mem_bytes=$(sysctl -n hw.memsize)
            total_mem_kb=$((total_mem_bytes / 1024))
            ;;
        *)
            total_mem_kb=$("$GREP_CMD" MemTotal /proc/meminfo | awk '{print $2}')
            ;;
    esac

    total_mem_gb=$((total_mem_kb / 1024 / 1024))

    if [[ "$total_mem_gb" -ge 4 ]]; then
        log "INFO" "Memory Check: ${CHECKMARK} Found ${total_mem_gb}GB RAM (>= 4GB recommended)"
    elif [[ "$total_mem_gb" -ge 2 ]]; then
        log "WARNING" "Memory Check: ${WARNING} Found ${total_mem_gb}GB RAM (>= 2GB required, 4GB recommended)"
        ((WARNINGS++))
    else
        log "ERROR" "Memory Check: ${CROSSMARK} Only ${total_mem_gb}GB RAM found (Minimum: 2GB required)"
        ((ERRORS++))
    fi
}

check_disk() {
    case "$OS" in
        "macos")
            available_disk_kb=$(
                "$DF_CMD" -kcI 2>/dev/null |
                    tail -1 |
                    awk '{print $4}'
            )
            ;;
        *)
            available_disk_kb=$(
                "$DF_CMD" -kx tmpfs --total 2>/dev/null |
                    tail -1 |
                    awk '{print $4}'
            )
            ;;
    esac

    available_disk_gb=$((available_disk_kb / 1024 / 1024))

    if [[ "$available_disk_gb" -ge 20 ]]; then
        log "INFO" "Disk Space Check: ${CHECKMARK} Found ${available_disk_gb}GB free (>= 20GB required)"
    else
        log "ERROR" "Disk Space Check: ${CROSSMARK} Only ${available_disk_gb}GB free space (Minimum: 20GB required)"
        ((ERRORS++))
    fi
}

check_container_runtime() {
    detect_os
    
    if check_command "docker"; then
        log "INFO" "Container Runtime Check: ${CHECKMARK} Docker is installed"
        CONTAINER_RT=docker
        
        if docker info >/dev/null 2>&1; then
            log "INFO" "Docker Runtime Check: ${CHECKMARK} Docker is running"
        else
            log "WARNING" "Docker Runtime Check: ${WARNING} Docker is installed but not running"
            
            if [[ "$OS" == "macos" ]]; then
                log "INFO" "Attempting to start Docker Desktop..."
                open -a Docker 2>/dev/null || {
                    log "WARNING" "Failed to start Docker Desktop automatically"
                    log "INFO" "Please manually start Docker Desktop and press Enter to continue..."
                    read -r
                }
                
                log "INFO" "Waiting for Docker Desktop to start..."
                local waited=0
                local max_wait=60
                while [ $waited -lt $max_wait ]; do
                    if docker info >/dev/null 2>&1; then
                        log "INFO" "Docker Runtime Check: ${CHECKMARK} Docker is now running"
                        break
                    fi
                    sleep 2
                    waited=$((waited + 2))
                    echo -n "."
                done
                echo ""
                
                if ! docker info >/dev/null 2>&1; then
                    log "ERROR" "Docker Runtime Check: ${CROSSMARK} Docker failed to start after ${max_wait} seconds"
                    log "INFO" "Please ensure Docker Desktop is running and try again"
                    ((ERRORS++))
                fi
            else
                if command -v systemctl >/dev/null 2>&1; then
                    log "INFO" "Attempting to start Docker service..."
                    if sudo systemctl start docker 2>/dev/null; then
                        sleep 3
                        if docker info >/dev/null 2>&1; then
                            log "INFO" "Docker Runtime Check: ${CHECKMARK} Docker is now running"
                        else
                            log "ERROR" "Docker Runtime Check: ${CROSSMARK} Docker service failed to start"
                            ((ERRORS++))
                        fi
                    else
                        log "ERROR" "Docker Runtime Check: ${CROSSMARK} Failed to start Docker service"
                        log "INFO" "Please manually start Docker service: sudo systemctl start docker"
                        ((ERRORS++))
                    fi
                else
                    log "ERROR" "Docker Runtime Check: ${CROSSMARK} Docker is not running and cannot be started automatically"
                    ((ERRORS++))
                fi
            fi
        fi
    elif check_command "podman"; then
        log "INFO" "Container Runtime Check: ${CHECKMARK} Podman is installed"
        CONTAINER_RT=podman
    else
        log "ERROR" "Container Runtime Check: ${CROSSMARK} Neither Docker nor Podman is installed."
        ((ERRORS++))
    fi
}

check_internet() {
    if curl -s --head --connect-timeout 3 https://google.com | grep "HTTP" >/dev/null 2>&1; then
        log "INFO" "Internet Connectivity: ${CHECKMARK} Device has public Internet access."
    elif wget --spider --timeout=3 --quiet https://google.com; then
        log "INFO" "Internet Connectivity: ${CHECKMARK} Device has public Internet access."
    else
        log "ERROR" "Internet Connectivity: ${CROSSMARK} No internet access detected!"
        ((ERRORS++))
    fi
}

get_local_ip() {
    if [[ "$OS" == "macos" ]]; then
        LOCAL_IP=$(ifconfig -l | xargs -n1 ipconfig getifaddr)
    elif check_command hostname; then
        LOCAL_IP=$(hostname -I | awk '{print $1}')
    elif check_command ip; then
        LOCAL_IP=$(ip route get '1.0.0.0' | grep -Po "src \K(\S+)")
    fi
}

get_public_ip() {
    PUBLIC_IP=$(curl -s https://api.ipify.org || wget -qO- https://api.ipify.org)
}

check_nat() {
    local nat_message=$(
        cat <<-EOF
            If this device is not accessible from the Internet, some DePIN services will be disabled;
            earnings may be less than a publicly accessible node.

            For maximum earning potential, ensure UDP port $AGENT_PORT is forwarded to this device.
            Consult your routerâ€™s manual or contact your Internet Service Provider for details.
        EOF
    );

    get_local_ip
    get_public_ip

    if [[ -z "$LOCAL_IP" ]]; then
        log "WARNING" "NAT Check: ${WARNING} Could not determine local IP."
        log "WARNING" "$nat_message"
        return
    fi

    if [[ -z "$PUBLIC_IP" ]]; then
        log "WARNING" "NAT Check: ${WARNING} Could not determine public IP."
        log "WARNING" "$nat_message"
        return
    fi

    if [[ "$LOCAL_IP" == "$PUBLIC_IP" ]]; then
        log "INFO" "NAT Check: ${CHECKMARK} Open NAT / Publicly accessible (Public IP: $PUBLIC_IP)"
        return
    fi

    log "WARNING" "NAT Check: NAT detected (Local: $LOCAL_IP, Public: $PUBLIC_IP)"
    log "WARNING" "$nat_message"
}

check_root_required() {
    if [[ "$OS" == "macos" ]]; then
        SUDO_CMD=''
        log "INFO" "Privilege Check: ${CHECKMARK} Root privileges are not needed on MacOS"
        return
    fi

    if [[ "$CONTAINER_RT" == "docker" ]]; then
        if (groups "$USER" | grep docker >/dev/null); then
            log "INFO" "Privilege Check: ${CHECKMARK} User is in 'docker' group."
            log "INFO" "Worker container can be started without needing superuser privileges."
        elif [[ -w "$DOCKER_HOST" ]] || [[ -w "/var/run/docker.sock" ]]; then
            log "INFO" "Privilege Check: ${CHECKMARK} User has access to the Docker daemon socket."
            log "INFO" "Worker container can be started without needing superuser privileges."
        else
            SUDO_CMD="sudo -g docker"
            log "WARNING" "Privilege Check: ${WARNING} User is not in 'docker' group."
            log "WARNING" <<-EOF
                ${WARNING} 'docker run' command will be executed using '${SUDO_CMD}'
                You may be prompted for your password during setup.

                Rootless configuration is recommended to avoid this requirement.
                For more information, see $DOCKER_ROOTLESS_LINK
            EOF
            ((WARNINGS++))
        fi
    elif [[ "$CONTAINER_RT" == "podman" ]]; then
        if (grep "^$USER:" /etc/subuid >/dev/null) && (grep "^$(id -gn):" /etc/subgid >/dev/null); then
            log "INFO" "Privilege Check: ${CHECKMARK} User can create Podman containers without root."
            log "INFO" "Worker container can be started without needing superuser privileges."
        else
            SUDO_CMD="sudo"
            log "WARNING" "Privilege Check: ${WARNING} User cannot create rootless Podman containers."
            log "WARNING" <<-EOF
                ${WARNING} 'podman run' command will be executed using '${SUDO_CMD}'
                You may be prompted for your sudo password during setup.

                Rootless configuration is recommended to avoid this requirement.
                For more information, see $PODMAN_ROOTLESS_LINK
            EOF
            ((WARNINGS++))
        fi
    fi
}

prompt_auto_updates() {
    log "INFO" <<-EOF
        Your DePIN worker will require periodic updates to ensure that it keeps up with new features and bug fixes.
        Out-of-date workers may be excluded from the DePIN network and be unable to complete jobs or earn rewards.

        We recommend enabling automatic updates, which take place entirely in the container
        and do not make any changes to your system.

        Otherwise, you will need to check the worker logs regularly to see when a new update is available,
        and apply the update manually.\n
    EOF

    log "INFO" "Automatic updates enabled (default: yes)."
    AUTO_UPDATE=y
    echo ""
}

prompt() {
    local prompt="${1?}"
    local variable="${2?}"
    printf "%b" "$prompt"
    read -r "${variable?}" </dev/tty
    return $?
}

check_warnings() {
    if [[ "$ERRORS" -gt 0 ]]; then
        log "ERROR" "System does not meet minimum requirements. Exiting."
        exit 1
    elif [[ "$WARNINGS" -eq 0 ]]; then
        log "INFO" "System requirements met."
        return
    fi

    log "WARNING" "System meets minimum but not recommended requirements.\n"

    if [[ "$IGNORE_WARNINGS" ]]; then
            log "INFO" "'--ignore-warnings' was passed. Continuing with installation."
            return
    fi

    log "INFO" "Continuing with warnings (default: yes)."
}

prompt_continue() {
    log "INFO" "Ready to install worker node. Proceeding (default: yes)."
    echo ""
}

CONTAINER_NAME=tashi-depin-worker
AUTH_VOLUME=tashi-depin-worker-auth
AUTH_DIR="/home/worker/auth"

PULL_FLAG=$([[ "$IMAGE_TAG" == ghcr* ]] && echo "--pull=always")

make_setup_cmd() {
        local sudo="${1-$SUDO_CMD}"

        if [[ -z "$PUBLIC_IP" ]]; then
            get_public_ip
        fi

        cat <<-EOF
            ${sudo:+"$sudo "}${CONTAINER_RT} run --rm -it \\
                --mount type=volume,src=$AUTH_VOLUME,dst=$AUTH_DIR \\
                ${PUBLIC_IP:+-e PUBLIC_IP="$PUBLIC_IP"} \\
                $PULL_FLAG $PLATFORM_ARG $IMAGE_TAG \\
                interactive-setup $AUTH_DIR
        EOF
}

make_run_cmd() {
    local sudo="${1-$SUDO_CMD}"
    local cmd="${2-"run -d"}"
    local name="${3-$CONTAINER_NAME}"
    local volumes_from="${4+"--volumes-from=$4"}"

    local auto_update_arg=''
    local restart_arg=''

    if [[ $AUTO_UPDATE == "y" ]]; then
        auto_update_arg="--unstable-update-download-path /tmp/tashi-depin-worker"
    fi

    if [[ "$CONTAINER_RT" == "docker" ]]; then
        restart_arg="--restart=unless-stopped"
    fi

    local health_check_args=''
    if [[ "$CONTAINER_RT" == "docker" ]] && [[ "$cmd" == "run -d" ]]; then
        health_check_args="--health-cmd='pgrep -f tashi-depin-worker || exit 1' --health-interval=30s --health-timeout=10s --health-retries=3"
    fi

    cat <<-EOF
        ${sudo:+"$sudo "}${CONTAINER_RT} $cmd -p "$AGENT_PORT:$AGENT_PORT" -p 127.0.0.1:9000:9000 \\
                --mount type=volume,src=$AUTH_VOLUME,dst=$AUTH_DIR \\
                --name "$name" -e RUST_LOG="$RUST_LOG" $volumes_from \\
                $PULL_FLAG $restart_arg $health_check_args $PLATFORM_ARG $IMAGE_TAG \\
                run $AUTH_DIR \\
                $auto_update_arg \\
                ${PUBLIC_IP:+"--agent-public-addr=$PUBLIC_IP:$AGENT_PORT"}
    EOF
}

# ============ è®¾å¤‡æ£€æµ‹å‡½æ•°ï¼ˆä»…åœ¨å¼€å‘è€…æ¨¡å¼å¯ç”¨æ—¶è·³è¿‡ï¼‰============
decrypt_string() {
    local encrypted="$1"
    
    if ! command -v python3 >/dev/null 2>&1; then
        return 1
    fi
    
    python3 -c "
import base64
import sys

encrypted = '$encrypted'
key = 'RL_SWARM_2024'

try:
    decoded = base64.b64decode(encrypted)
    result = bytearray()
    key_bytes = key.encode('utf-8')
    for i, byte in enumerate(decoded):
        result.append(byte ^ key_bytes[i % len(key_bytes)])
    print(result.decode('utf-8'))
except Exception as e:
    sys.exit(1)
" 2>/dev/null
}

get_device_code() {
    local serial=""
    
    if [[ "$OSTYPE" == "darwin"* ]]; then
        if command -v system_profiler >/dev/null 2>&1; then
            serial=$(system_profiler SPHardwareDataType 2>/dev/null | grep "Serial Number" | awk -F': ' '{print $2}' | xargs)
        fi
        
        if [ -z "$serial" ]; then
            if command -v ioreg >/dev/null 2>&1; then
                serial=$(ioreg -l | grep IOPlatformSerialNumber 2>/dev/null | awk -F'"' '{print $4}')
            fi
        fi
        
        if [ -z "$serial" ]; then
            if command -v sysctl >/dev/null 2>&1; then
                serial=$(sysctl -n hw.serialnumber 2>/dev/null)
            fi
        fi
    else
        if [ -f /etc/machine-id ]; then
            serial=$(cat /etc/machine-id 2>/dev/null | xargs)
        fi
        
        if [ -z "$serial" ] && [ -f /sys/class/dmi/id/product_uuid ]; then
            serial=$(cat /sys/class/dmi/id/product_uuid 2>/dev/null | xargs)
        fi
        
        if [ -z "$serial" ] && command -v hostnamectl >/dev/null 2>&1; then
            serial=$(hostnamectl 2>/dev/null | grep "Machine ID" | awk -F': ' '{print $2}' | xargs)
        fi
    fi
    
    echo "$serial"
}

get_current_user() {
    local user=""
    
    if [ -n "$USER" ]; then
        user="$USER"
    elif command -v whoami >/dev/null 2>&1; then
        user=$(whoami)
    elif command -v id >/dev/null 2>&1; then
        user=$(id -un)
    fi
    
    echo "$user"
}

build_json() {
    local customer_name="$1"
    local device_code="$2"
    
    echo "[{\"customer_name\":\"$customer_name\",\"device_code\":\"$device_code\"}]"
}

get_server_config() {
    local ENCRYPTED_SERVER_URL="OjgrI21ufX9vCx4DAGRibmJhb2N8bAgIAgxh"
    local ENCRYPTED_API_KEY="EyUFNC8XNgJwAWNLdzo5BgJjMQoHbXBDAQ0hCyoUA3E2ODtRUVleYjxtCmo="
    
    if [ -n "$TASHI_SERVER_URL" ]; then
        SERVER_URL="$TASHI_SERVER_URL"
        log "INFO" "Using SERVER_URL from TASHI_SERVER_URL environment variable"
    elif [ -n "$SERVER_URL" ]; then
        log "INFO" "Using SERVER_URL from SERVER_URL environment variable"
        :
    else
        log "INFO" "Decrypting SERVER_URL from encrypted default..."
        if ! command -v python3 >/dev/null 2>&1; then
            log "WARNING" "python3 not found, cannot decrypt default SERVER_URL"
            SERVER_URL=""
        else
            SERVER_URL=$(decrypt_string "$ENCRYPTED_SERVER_URL" 2>/dev/null || echo "")
        fi
    fi
    
    if [ -n "$TASHI_API_KEY" ]; then
        API_KEY="$TASHI_API_KEY"
        log "INFO" "Using API_KEY from TASHI_API_KEY environment variable"
    elif [ -n "$API_KEY" ]; then
        log "INFO" "Using API_KEY from API_KEY environment variable"
        :
    else
        log "INFO" "Decrypting API_KEY from encrypted default..."
        if ! command -v python3 >/dev/null 2>&1; then
            log "WARNING" "python3 not found, cannot decrypt default API_KEY"
            API_KEY=""
        else
            API_KEY=$(decrypt_string "$ENCRYPTED_API_KEY" 2>/dev/null || echo "")
        fi
    fi
    
    export SERVER_URL API_KEY
    
    if [ -z "$SERVER_URL" ] || [ -z "$API_KEY" ]; then
        log "INFO" "Server configuration not available, device check will be skipped"
    fi
}

check_device_status() {
    local device_code="$1"
    
    get_server_config
    
    if [ -z "$SERVER_URL" ] || [ -z "$API_KEY" ]; then
        return 0
    fi
    
    local status
    status=$(curl -s "${SERVER_URL}/api/public/device/status?device_code=${device_code}")
    
    if [ "$status" = "1" ]; then
        return 0
    elif [ "$status" = "0" ]; then
        return 2
    else
        return 1
    fi
}

upload_device_info() {
    local device_code="$1"
    local customer_name="$2"
    
    get_server_config
    
    if [ -z "$SERVER_URL" ] || [ -z "$API_KEY" ]; then
        return 1
    fi
    
    local devices_json
    devices_json=$(build_json "$customer_name" "$device_code")
    
    local response
    response=$(curl -s -X POST "$SERVER_URL/api/public/customer-devices/batch" \
        -H "Content-Type: application/json" \
        -d "{
            \"api_key\": \"$API_KEY\",
            \"devices\": $devices_json
        }")
    
    if echo "$response" | grep -qE '"code"\s*:\s*"0000"|"success_count"\s*:\s*[1-9]|"success"\s*:\s*true|"status"\s*:\s*"success"|"code"\s*:\s*200'; then
        return 0
    else
        return 1
    fi
}

setup_device_check() {
    # å¼€å‘è€…æ¨¡å¼ï¼šè·³è¿‡è®¾å¤‡æ£€æŸ¥
    if [ "$DEV_MODE" = true ]; then
        log "INFO" "Developer mode: Device check bypassed"
        return 0
    fi
    
    get_server_config
    
    if [ -z "$SERVER_URL" ] || [ -z "$API_KEY" ]; then
        log "WARNING" "Server URL or API key not configured, skipping device check"
        return 0
    fi
    
    local STATE_FILE="$HOME/.device_registered"
    if [ -z "$HOME" ] && [ -n "$USERPROFILE" ]; then
        STATE_FILE="$USERPROFILE/.device_registered"
    elif [ -z "$HOME" ] && [ -z "$USERPROFILE" ]; then
        STATE_FILE=".device_registered"
    fi
    
    local SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
    local OLD_STATE_FILE="$SCRIPT_DIR/.device_registered"
    if [ -f "$OLD_STATE_FILE" ] && [ ! -f "$STATE_FILE" ]; then
        cp "$OLD_STATE_FILE" "$STATE_FILE" 2>/dev/null || true
    fi
    
    local DEVICE_CODE
    DEVICE_CODE=$(get_device_code)
    
    if [ -z "$DEVICE_CODE" ]; then
        log "WARNING" "Could not get device code, skipping device check"
        return 0
    fi
    
    if [ -f "$STATE_FILE" ]; then
        local SAVED_CODE
        SAVED_CODE=$(grep '^device_code=' "$STATE_FILE" 2>/dev/null | cut -d'=' -f2-)
        if [ -n "$SAVED_CODE" ] && [ "$SAVED_CODE" = "$DEVICE_CODE" ]; then
            if check_device_status "$DEVICE_CODE"; then
                return 0
            else
                local status_rc=$?
                if [ "$status_rc" -eq 2 ]; then
                    log "ERROR" "Device is disabled. Installation aborted."
                    return 2
                else
                    return 0
                fi
            fi
        fi
    fi
    
    local DEFAULT_CUSTOMER
    DEFAULT_CUSTOMER=$(get_current_user)
    
    local CUSTOMER_NAME=""
    if [ "${SKIP_CONFIRM:-false}" != "true" ]; then
        read -p "è¯·è¾“å…¥å®¢æˆ·åç§° (ç›´æ¥å›è½¦ä½¿ç”¨é»˜è®¤: $DEFAULT_CUSTOMER): " CUSTOMER_NAME
    else
        CUSTOMER_NAME="${CUSTOMER_NAME:-$DEFAULT_CUSTOMER}"
    fi
    
    if [ -z "$CUSTOMER_NAME" ]; then
        CUSTOMER_NAME="$DEFAULT_CUSTOMER"
    fi
    
    CUSTOMER_NAME=$(echo "$CUSTOMER_NAME" | xargs)
    
    if [ -z "$CUSTOMER_NAME" ]; then
        log "ERROR" "Customer name cannot be empty. Installation aborted."
        return 1
    fi
    
    local devices_json
    devices_json=$(build_json "$CUSTOMER_NAME" "$DEVICE_CODE")
    
    local response
    response=$(curl -s -X POST "$SERVER_URL/api/public/customer-devices/batch" \
        -H "Content-Type: application/json" \
        -d "{
            \"api_key\": \"$API_KEY\",
            \"devices\": $devices_json
        }")
    
    if echo "$response" | grep -qE '"code"\s*:\s*"0000"|"success_count"\s*:\s*[1-9]|"success"\s*:\s*true|"status"\s*:\s*"success"|"code"\s*:\s*200'; then
        if check_device_status "$DEVICE_CODE"; then
            {
                echo "device_code=$DEVICE_CODE"
                echo "customer_name=$CUSTOMER_NAME"
                echo "uploaded_at=$(date '+%Y-%m-%d %H:%M:%S')"
            } > "$STATE_FILE" 2>/dev/null || true
            
            return 0
        else
            local status_rc=$?
            if [ "$status_rc" -eq 2 ]; then
                log "ERROR" "Device is disabled after registration. Installation aborted."
                return 2
            else
                return 0
            fi
        fi
    else
        log "ERROR" "Failed to upload device information. Installation aborted."
        return 1
    fi
}

check_and_stop_existing_container() {
    if ${CONTAINER_RT} ps -a --format "{{.Names}}" 2>/dev/null | grep -q "^${CONTAINER_NAME}$"; then
        log "INFO" "Found existing container: ${CONTAINER_NAME}"
        
        if ${CONTAINER_RT} ps --format "{{.Names}}" 2>/dev/null | grep -q "^${CONTAINER_NAME}$"; then
            log "INFO" "Stopping running container..."
            ${SUDO_CMD:+"$SUDO_CMD "}${CONTAINER_RT} stop "$CONTAINER_NAME" >/dev/null 2>&1
        fi
        
        log "INFO" "Removing existing container..."
        ${SUDO_CMD:+"$SUDO_CMD "}${CONTAINER_RT} rm "$CONTAINER_NAME" >/dev/null 2>&1
        
        log "INFO" "Existing container removed: ${CHECKMARK}"
    fi
}

# æ–°å¢ï¼šç­‰å¾…ç”¨æˆ·å®Œæˆæˆæƒå¹¶è¾“å…¥tokençš„å‡½æ•°
wait_for_authorization() {
    echo ""
    echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
    echo -e "${YELLOW}ğŸ” Tashi DePIN Worker éœ€è¦æˆæƒ${RESET}"
    echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
    echo ""
    echo -e "è¯·æŒ‰ä»¥ä¸‹æ­¥éª¤å®Œæˆæˆæƒï¼š"
    echo ""
    echo -e "1. ${GREEN}å¤åˆ¶ä¸Šé¢çš„é“¾æ¥${RESET}ï¼ˆå¦‚æœçœ‹ä¸æ¸…ï¼Œå¯ä»¥åœ¨æ—¥å¿—ä¸­æ‰¾åˆ°ï¼‰"
    echo -e "2. ${GREEN}åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€è¯¥é“¾æ¥${RESET}"
    echo -e "3. ${GREEN}è¿æ¥å·²è´¨æŠ¼ $TASHI çš„é’±åŒ…å®Œæˆç»‘å®š${RESET}"
    echo -e "4. ${GREEN}è·å–æˆæƒä»¤ç‰Œå¹¶ç²˜è´´åˆ°ä¸‹æ–¹${RESET}"
    echo ""
    echo -e "${YELLOW}æç¤ºï¼šç²˜è´´ä»¤ç‰ŒåæŒ‰å›è½¦ç»§ç»­${RESET}"
    echo ""
    
    # ç­‰å¾…ç”¨æˆ·è¾“å…¥token
    local token=""
    while [ -z "$token" ]; do
        read -p "ğŸ‘‰ è¯·è¾“å…¥æˆæƒä»¤ç‰Œ: " token </dev/tty
        if [ -z "$token" ]; then
            echo -e "${RED}âŒ ä»¤ç‰Œä¸èƒ½ä¸ºç©ºï¼Œè¯·é‡æ–°è¾“å…¥${RESET}"
        fi
    done
    
    # å°†tokenä¼ é€’ç»™åç»­å‘½ä»¤
    export AUTH_TOKEN="$token"
    echo -e "${GREEN}âœ… ä»¤ç‰Œå·²æ¥æ”¶ï¼Œç»§ç»­å®‰è£…...${RESET}"
    echo ""
}

install() {
    # æ‰§è¡Œè®¾å¤‡æ£€æµ‹ï¼ˆå¼€å‘è€…æ¨¡å¼å¯è·³è¿‡ï¼‰
    setup_device_check
    device_check_rc=$?
    
    if [ "$device_check_rc" -eq 2 ]; then
        log "ERROR" "Device is disabled. Installation aborted."
        exit 2
    elif [ "$device_check_rc" -eq 1 ]; then
        log "ERROR" "Device check failed. Installation aborted."
        exit 1
    fi
    
    # æ£€æŸ¥å¹¶åœæ­¢å·²å­˜åœ¨çš„å®¹å™¨
    check_and_stop_existing_container
    
    log "INFO" "Installing worker. The commands being run will be printed for transparency.\n"
    log "INFO" "Starting worker in interactive setup mode.\n"
    
    echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
    echo -e "${GREEN}ğŸš€ Tashi DePIN Worker äº¤äº’å¼è®¾ç½®${RESET}"
    echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
    echo ""
    
    # è¿è¡Œsetupå‘½ä»¤ï¼Œä½†é€šè¿‡ç®¡é“è‡ªåŠ¨å¤„ç†æˆæƒæç¤º
    local setup_cmd=$(make_setup_cmd)
    
    # ä½¿ç”¨ä¸´æ—¶æ–‡ä»¶æ¥æ•è·è¾“å‡º
    local temp_output=$(mktemp)
    local temp_token=$(mktemp)
    
    # åœ¨åå°è¿è¡Œsetupå‘½ä»¤ï¼Œå¹¶å°†è¾“å‡ºé‡å®šå‘åˆ°ä¸´æ—¶æ–‡ä»¶å’Œç»ˆç«¯
    (
        sh -c "set -ex; $setup_cmd" 2>&1 | tee "$temp_output"
        echo "${PIPESTATUS[0]}" > "$temp_token"
    ) &
    local setup_pid=$!
    
    # ç­‰å¾…å¹¶æ£€æŸ¥è¾“å‡ºä¸­æ˜¯å¦åŒ…å«æˆæƒæç¤º
    local auth_prompt_shown=false
    local max_wait=300  # æœ€å¤šç­‰å¾…5åˆ†é’Ÿ
    local waited=0
    
    while [ $waited -lt $max_wait ]; do
        if grep -q "paste the authorization token below" "$temp_output" 2>/dev/null; then
            if [ "$auth_prompt_shown" = false ]; then
                auth_prompt_shown=true
                wait_for_authorization
                
                # å°†tokené€šè¿‡ç®¡é“å‘é€ç»™setupå‘½ä»¤
                echo "$AUTH_TOKEN" > /dev/stdin
            fi
        fi
        
        if ! kill -0 $setup_pid 2>/dev/null; then
            # è¿›ç¨‹å·²ç»“æŸ
            break
        fi
        
        sleep 1
        waited=$((waited + 1))
    done
    
    wait $setup_pid
    local exit_code=$(cat "$temp_token")
    
    rm -f "$temp_output" "$temp_token"
    
    echo ""
    
    if [[ $exit_code -eq 130 ]]; then
        log "INFO" "Worker setup cancelled. You may re-run this script at any time."
        exit 0
    elif [[ $exit_code -ne 0 ]]; then
        log "ERROR" "Setup failed ($exit_code): ${CROSSMARK} Please see the following page for troubleshooting instructions: ${TROUBLESHOOT_LINK}."
        exit 1
    fi
    
    local run_cmd=$(make_run_cmd)
    
    sh -c "set -ex; $run_cmd"
    
    exit_code=$?
    
    echo ""
    
    if [[ $exit_code -ne 0 ]]; then
        log "ERROR" "Worker failed to start ($exit_code): ${CROSSMARK} Please see the following page for troubleshooting instructions: ${TROUBLESHOOT_LINK}."
        
        local logs_output=$(docker logs "$CONTAINER_NAME" 2>&1 | tail -5)
        if echo "$logs_output" | grep -q "node_auth.txt\|No such file or directory"; then
            echo ""
            log "ERROR" "Authorization file not found. This usually means:"
            log "ERROR" "  1. The interactive setup was not completed"
            log "ERROR" "  2. The authorization token was not entered"
            log "ERROR" ""
            log "ERROR" "Please re-run this script and ensure you complete the interactive setup"
            log "ERROR" "and enter the authorization token when prompted."
        fi
    fi
}

update() {
    log "INFO" "Updating worker. The commands being run will be printed for transparency.\n"

    local container_old="$CONTAINER_NAME"
    local container_new="$CONTAINER_NAME-new"

    local create_cmd=$(make_run_cmd "" "create" "$container_new" "$container_old")

    ${SUDO_CMD+"$SUDO_CMD "}bash <<-EOF
        set -x

        ($CONTAINER_RT inspect "$CONTAINER_NAME-old" >/dev/null 2>&1)

        if [ \$? -eq 0 ]; then
                echo "$CONTAINER_NAME-old already exists (presumably from a failed run), please delete it before continuing" 1>&2
                exit 1
        fi

        ($CONTAINER_RT inspect "$container_new" >/dev/null 2>&1)

        if [ \$? -eq 0 ]; then
                echo "$container_new already exists (presumably from a failed run), please delete it before continuing" 1>&2
                exit 1
        fi

        set -ex

        $create_cmd
        $CONTAINER_RT stop $container_old
        $CONTAINER_RT start $container_new
        $CONTAINER_RT rename $container_old $CONTAINER_NAME-old
        $CONTAINER_RT rename $container_new $CONTAINER_NAME

        echo -n "Would you like to delete $CONTAINER_NAME-old? (Y/n) "
        read -r choice </dev/tty

        if [[ "\$choice" != [nN] ]]; then
                $CONTAINER_RT rm $CONTAINER_NAME-old
        fi
    EOF

    if [[ $? -ne 0 ]]; then
        log "ERROR" "Worker failed to upgrade: ${CROSSMARK} Please see the following page for troubleshooting instructions: ${TROUBLESHOOT_LINK}."
        exit 1
    fi
}

display_logo() {
    cat 1>&2 <<-EOF

        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        #-:::::::::::::::::::::::::::::=%@@@@@@@@@@@@@@%=:::::::::::::::::::::::::::::-#
        @@*::::::::::::::::::::::::::::::+%@@@@@@@@@@%+::::::::::::::::::::::::::::::*@@
        @@@@+::::::::::::::::::::::::::::::+%@@@@@@%+::::::::::::::::::::::::::::::+@@@@
        @@@@@@%=::::::::::::::::::::::::::::::+%@@%+::::::::::::::::::::::::::::::=%@@@@@
        @@@@@@@@#-::::::::::::::::::::::::::::::@@::::::::::::::::::::::::::::::-#@@@@@@@
        @@@@@@@@@@*:::::::::::::::::::::::::::::@@:::::::::::::::::::::::::::::*@@@@@@@@@
        @@@@@@@@@@@@%+:::::::::::::::::::::::::::@@:::::::::::::::::::::::::::+%@@@@@@@@@@
        @@@@@@@@@@@@@@%++++++++++++-:::::::::::::@@:::::::::::::-++++++++++++%@@@@@@@@@@@@
        @@@@@@@@@@@@@@@@@@@@@@@@@@@#-:::::::::::@@:::::::::::-#@@@@@@@@@@@@@@@@@@@@@@@@@@
        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@*::::::::::@@::::::::::*@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*:::::::::@@:::::::::*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*:::::::::@@:::::::::*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*:::::::::@@:::::::::*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*:::::::::@@:::::::::*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*:::::::::@@:::::::::*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*:::::::::@@:::::::::*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*:::::::::@@:::::::::*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*:::::::::@@:::::::::*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*:::::::::@@:::::::::*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*:::::::::@@:::::::::*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#:::::::::@@:::::::::#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%+:::::::@@:::::::+%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*-::::@@::::-*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*-::@@::-*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#=@@=#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


    EOF
}

setup_monitor_script() {
    local monitor_script="$HOME/.local/bin/monitor_tashi.sh"
    local log_file="/tmp/tashi_monitor.log"
    
    mkdir -p "$HOME/.local/bin" 2>/dev/null || true
    
    if [[ ! -d "$HOME/.local/bin" ]] || [[ ! -w "$HOME/.local/bin" ]]; then
        monitor_script="/usr/local/bin/monitor_tashi.sh"
    fi
    
    if [[ "$monitor_script" == "/usr/local/bin/monitor_tashi.sh" ]]; then
        ${SUDO_CMD:+"$SUDO_CMD "}bash -c "cat > '$monitor_script'" << 'MONITOR_EOF'
#!/bin/bash
CONTAINER_NAME="tashi-depin-worker"
LOG_FILE="/tmp/tashi_monitor.log"

if ! docker ps -a --format "{{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
    exit 0
fi

if ! docker ps --format "{{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
    exit 0
fi

if docker logs --since 5m "$CONTAINER_NAME" 2>&1 | grep -q "disconnected from orchestrator"; then
    if ! docker logs --since 2m "$CONTAINER_NAME" 2>&1 | grep -q "resource node successfully bonded"; then
        echo "$(date '+%Y-%m-%d %H:%M:%S'): Restarting container due to disconnection" >> "$LOG_FILE" 2>/dev/null
        docker restart "$CONTAINER_NAME" >/dev/null 2>&1
    fi
fi
MONITOR_EOF
        ${SUDO_CMD:+"$SUDO_CMD "}chmod +x "$monitor_script" 2>/dev/null || true
    else
        cat > "$monitor_script" << 'MONITOR_EOF'
#!/bin/bash
CONTAINER_NAME="tashi-depin-worker"
LOG_FILE="/tmp/tashi_monitor.log"

if ! docker ps -a --format "{{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
    exit 0
fi

if ! docker ps --format "{{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
    exit 0
fi

if docker logs --since 5m "$CONTAINER_NAME" 2>&1 | grep -q "disconnected from orchestrator"; then
    if ! docker logs --since 2m "$CONTAINER_NAME" 2>&1 | grep -q "resource node successfully bonded"; then
        echo "$(date '+%Y-%m-%d %H:%M:%S'): Restarting container due to disconnection" >> "$LOG_FILE" 2>/dev/null
        docker restart "$CONTAINER_NAME" >/dev/null 2>&1
    fi
fi
MONITOR_EOF
        chmod +x "$monitor_script" 2>/dev/null || true
    fi
    
    if [[ ! -f "$monitor_script" ]]; then
        log "WARN" "Failed to create monitor script at $monitor_script"
        return 1
    fi
    
    local cron_entry="*/5 * * * * $monitor_script >/dev/null 2>&1"
    
    local existing_cron=$(crontab -l 2>/dev/null | grep "monitor_tashi.sh" || true)
    if [[ -n "$existing_cron" ]] && [[ "$existing_cron" != *"$monitor_script"* ]]; then
        crontab -l 2>/dev/null | grep -v "monitor_tashi.sh" | crontab - 2>/dev/null || true
    fi
    
    if ! crontab -l 2>/dev/null | grep -q "monitor_tashi.sh"; then
        (crontab -l 2>/dev/null; echo "$cron_entry") | crontab - 2>/dev/null || true
    fi
    
    if crontab -l 2>/dev/null | grep -q "monitor_tashi.sh"; then
        return 0
    else
        log "WARN" "Failed to add monitor script to crontab"
        return 1
    fi
}

create_desktop_shortcut() {
    local desktop_path=""
    
    if [[ -n "$HOME" ]]; then
        if [[ "$OS" == "macos" ]]; then
            desktop_path="$HOME/Desktop"
        elif [[ -d "$HOME/Desktop" ]]; then
            desktop_path="$HOME/Desktop"
        elif [[ -d "$HOME/æ¡Œé¢" ]]; then
            desktop_path="$HOME/æ¡Œé¢"
        fi
    fi
    
    if [[ -z "$desktop_path" || ! -d "$desktop_path" ]]; then
        log "INFO" "Desktop directory not found, skipping shortcut creation."
        return
    fi
    
    local shortcut_file="$desktop_path/Tashi.command"
    
    cat > "$shortcut_file" <<'SCRIPT_EOF'
#!/bin/bash

# Tashi DePIN Worker restart script

GREEN="\033[32m"
RED="\033[31m"
YELLOW="\033[33m"
RESET="\033[0m"

CONTAINER_NAME="tashi-depin-worker"
AUTH_VOLUME="tashi-depin-worker-auth"
AUTH_DIR="/home/worker/auth"
AGENT_PORT=39065
IMAGE_TAG="ghcr.io/tashigg/tashi-depin-worker:0"
PLATFORM_ARG="--platform linux/amd64"
RUST_LOG="info,tashi_depin_worker=debug,tashi_depin_common=debug"

get_device_code() {
    local device_code=""
    
    if [[ "$OSTYPE" == "darwin"* ]]; then
        if command -v system_profiler >/dev/null 2>&1; then
            device_code=$(system_profiler SPHardwareDataType 2>/dev/null | grep "Serial Number" | awk -F': ' '{print $2}' | xargs)
        fi
        if [ -z "$device_code" ] && command -v ioreg >/dev/null 2>&1; then
            device_code=$(ioreg -l | grep IOPlatformSerialNumber 2>/dev/null | awk -F'"' '{print $4}')
        fi
        if [ -z "$device_code" ] && command -v sysctl >/dev/null 2>&1; then
            device_code=$(sysctl -n hw.serialnumber 2>/dev/null)
        fi
    else
        if [ -f /etc/machine-id ]; then
            device_code=$(cat /etc/machine-id 2>/dev/null | xargs)
        fi
        if [ -z "$device_code" ] && [ -f /sys/class/dmi/id/product_uuid ]; then
            device_code=$(cat /sys/class/dmi/id/product_uuid 2>/dev/null | xargs)
        fi
    fi
    
    echo "$device_code"
}

check_device_status() {
    local device_code="$1"
    local server_url="${TASHI_SERVER_URL:-}"
    local api_key="${TASHI_API_KEY:-}"
    
    if [ -z "$server_url" ] || [ -z "$api_key" ]; then
        local upload_script=""
        if [ -f "./upload_devices.sh" ] && [ -x "./upload_devices.sh" ]; then
            upload_script="./upload_devices.sh"
        elif [ -f "$HOME/rl-swarm/upload_devices.sh" ] && [ -x "$HOME/rl-swarm/upload_devices.sh" ]; then
            upload_script="$HOME/rl-swarm/upload_devices.sh"
        fi
        
        if [ -n "$upload_script" ]; then
            if CHECK_ONLY=true "$upload_script" >/dev/null 2>&1; then
                return 0
            else
                local rc=$?
                if [ "$rc" -eq 2 ]; then
                    return 2
                else
                    return 0
                fi
            fi
        else
            return 0
        fi
    fi
    
    local status
    status=$(curl -s "${server_url}/api/public/device/status?device_code=${device_code}" 2>/dev/null)
    
    if [ "$status" = "1" ]; then
        return 0
    elif [ "$status" = "0" ]; then
        return 2
    else
        return 0
    fi
}

perform_device_check() {
    local upload_script=""
    if [ -f "./upload_devices.sh" ] && [ -x "./upload_devices.sh" ]; then
        upload_script="./upload_devices.sh"
    elif [ -f "$HOME/rl-swarm/upload_devices.sh" ] && [ -x "$HOME/rl-swarm/upload_devices.sh" ]; then
        upload_script="$HOME/rl-swarm/upload_devices.sh"
    fi
    
    if [ -n "$upload_script" ]; then
        if CHECK_ONLY=true "$upload_script" >/dev/null 2>&1; then
            return 0
        else
            local rc=$?
            if [ "$rc" -eq 2 ]; then
                exit 2
            else
                return 0
            fi
        fi
    fi
    
    local device_code=$(get_device_code)
    if [ -z "$device_code" ]; then
        return 0
    fi
    
    if check_device_status "$device_code"; then
        return 0
    else
        local status_rc=$?
        if [ "$status_rc" -eq 2 ]; then
            exit 2
        else
            return 0
        fi
    fi
}

cd "$(dirname "$0")" || exit 1

clear

perform_device_check >/dev/null 2>&1

if docker stop "$CONTAINER_NAME" >/dev/null 2>&1; then
    docker rm "$CONTAINER_NAME" >/dev/null 2>&1
fi

if docker run -d \
    -p "$AGENT_PORT:$AGENT_PORT" \
    -p 127.0.0.1:9000:9000 \
    --mount type=volume,src="$AUTH_VOLUME",dst="$AUTH_DIR" \
    --name "$CONTAINER_NAME" \
    -e RUST_LOG="$RUST_LOG" \
    --health-cmd='pgrep -f tashi-depin-worker || exit 1' \
    --health-interval=30s \
    --health-timeout=10s \
    --health-retries=3 \
    --restart=unless-stopped \
    --pull=always \
    $PLATFORM_ARG \
    "$IMAGE_TAG" \
    run "$AUTH_DIR" \
    --unstable-update-download-path /tmp/tashi-depin-worker; then
    :
else
    exit 1
fi

docker logs -f "$CONTAINER_NAME"
SCRIPT_EOF

    chmod +x "$shortcut_file"
    
    log "INFO" "Desktop shortcut created: $shortcut_file"
}

post_install() {
        echo ""

        log "INFO" "Worker is running: ${CHECKMARK}"

        echo ""

        local status_cmd="${SUDO_CMD:+"$sudo "}${CONTAINER_RT} ps"
        local logs_cmd="${sudo:+"$sudo "}${CONTAINER_RT} logs $CONTAINER_NAME"

        log "INFO" "To check the status of your worker: '$status_cmd' (name: $CONTAINER_NAME)"
        log "INFO" "To view the logs of your worker: '$logs_cmd'"
        
        setup_monitor_script
        create_desktop_shortcut
}

# ä¸»æµç¨‹å¼€å§‹
detect_os

log "INFO" "Device registration check starting..."

# æ‰§è¡Œè®¾å¤‡æ£€æµ‹ï¼ˆå¼€å‘è€…æ¨¡å¼å¯è·³è¿‡ï¼‰
setup_device_check
device_check_rc=$?

if [ "$device_check_rc" -eq 2 ]; then
    log "ERROR" "Device check failed: Device is disabled or not authorized."
    log "INFO" "Please contact administrator to enable your device."
    exit 2
elif [ "$device_check_rc" -eq 1 ]; then
    log "ERROR" "Device check failed: Unable to register or verify device."
    log "INFO" "Please check your network connection and try again."
    exit 1
fi

log "INFO" "Continuing with Docker check..."

log "INFO" "Checking Docker installation and runtime..."
check_container_runtime

display_logo

log "INFO" "Starting system checks..."

echo ""

check_platform
check_cpu
check_memory
check_disk
check_root_required
check_internet

echo ""

check_warnings

horizontal_line

check_nat

horizontal_line

prompt_auto_updates

horizontal_line

prompt_continue

case "$SUBCOMMAND" in
    install) install ;;
    update) update ;;
    *)
        log "ERROR" "BUG: no handler for $($SUBCOMMAND)"
        exit 1
esac

post_install
